package szaqal;

/**
 * 求二进制中1的个数
 *
 * @author http://15838341661-139-com.iteye.com/blog/1642525
 * @date 2016/10/14.
 *
 * 参考资料:
 * 1. http://blog.csdn.net/justpub/article/details/2292823

2. http://www.inwap.com/pdp10/hbaker/hakmem/hacks.html#item169

3. http://tekpool.wordpress.com/category/bit-count/

4. gurmeet.net/puzzles/fast-bit-counting-routines/

5. http://www.tekpool.com/node/2675

6. http://hi.baidu.com/rangemq/blog/item/9f918c8f83997eecf11f367b.html

7. http://stackoverflow.com/questions/109023/best-algorithm-to-count-the-number-of-set-bits-in-a-32-bit-integer

8. http://mindprod.com/jgloss/bitcount.html
 *
 */
public class BinaryOperateTest {

    public void generalUsed(){
        // 1、左移( << )
        // 0000 0000 0000 0000 0000 0000 0000 0101 然后左移2位后，低位补0：//
        // 0000 0000 0000 0000 0000 0000 0001 0100 换算成10进制为20
        System.out.println(5 << 2);// 运行结果是20

        // 2、右移( >> ) 高位补符号位
        // 0000 0000 0000 0000 0000 0000 0000 0101 然后右移2位，高位补0：
        // 0000 0000 0000 0000 0000 0000 0000 0001
        System.out.println(5 >> 2);// 运行结果是1

        // 3、无符号右移( >>> ) 高位补0
        // 例如 -5换算成二进制后为：0101 取反加1为1011             原码->反码->加1变取补码
        // 1111 1111 1111 1111 1111 1111 1111 1011
        // 我们分别对5进行右移3位、 -5进行右移3位和无符号右移3位：
        System.out.println(5 >> 3);// 结果是0
        System.out.println(-5 >> 3);// 结果是-1     有符号位的右移三位后数值为   (负的  取反加一)
        System.out.println(-5 >>> 3);// 结果是536870911

        // 4、位与( & )
        // 位与：第一个操作数的的第n位于第二个操作数的第n位如果都是1，那么结果的第n为也为1，否则为0   相同的为1
        System.out.println(5 & 3);// 结果为1
        System.out.println(4 & 1);// 结果为0

        // 5、位或( | )
        // 第一个操作数的的第n位于第二个操作数的第n位 只要有一个是1，那么结果的第n为也为1，否则为0   有一个为1即为1
        System.out.println(5 | 3);// 结果为7

        // 6、位异或( ^ )
        // 第一个操作数的的第n位于第二个操作数的第n位 相反，那么结果的第n为也为1，否则为0          相反的为1
        System.out.println(5 ^ 3);//结果为6

        // 7、位非( ~ )
        // 操作数的第n位为1，那么结果的第n位为0，反之。   取反
        System.out.println(~5);// 结果为-6
    }


    /**
     * 对于一个正整数如果是偶数，该数的二进制数的最后一位是 0 ，反之若是奇数，则该数的二进制数的最后一位是 1 。因此，可以考虑利用位移、判断奇偶来实现。
     */
    public int bitCount(int x) {
        int count = 0;
        while (x != 0) {
            if (x % 2 != 0) {  //判断奇偶数
                count++;
            }
            /**
             *
             * 传进来的是1的话      得到的结果为1
             *          2          结果为1
             *          3          结果为2
             *          -1         1111 1111 1111 1111 1111 1111 1111 1111 => 每次无符号右移一位，共32
             *
             */
            x = x >>> 1;
        }
        return count;
    }

    /**
     * 同bitCount4
     * 然后让我写了一个计算一个int里面二进制有几个1，然后我用最高效的方法（n=n&n-1）写出来
     *
     * 每次把最右边的1消掉把其他数向右移
     * @param n
     * @return
     */
    public int bitCount222(int n){
        int count = 0;
        while(n != 0){
            /**
             *     传进来的为5       0101        n-1为4   0100     二者取&  0100把1消掉了      继续0100&0011得0  此时count已经为2
             */
            n = n & (n-1);
            count++;
        }
        return count;
    }

    /**
     * 知道了位移操作同样可以判断奇偶，且效率高于除法操作（“ % ”求余操作最后还是化为除法操作）那就可以用位移来代替上的求余运算。
     * <p/>
     * 因为 x & 1 的结果为 1 或 0 ，为 1 的时候 count+=1 ，为 0 的时候 count+=0
     * <p/>
     * 则：
     * <p/>
     * If(x&1==1){
     * <p/>
     * count++;
     * <p/>
     * }
     * <p/>
     * 可简化为： count+ = x&1;
     */

    public int bitCount2(int x) {
        int count = 0;
        while (x != 0) {
            /**
             * 相当于判断奇偶，奇数时加1     每次循环会向右移动一位
             */
            count += x & 1;
            x = x >>> 1;
        }
        return count;
    }

    /**
     * 正整数的二进制数最高位为 0 ，负整数和二进制数最高们为 1 ，则可利用左移、判断正负来实现 1 的个数的计算。
     */
    public int bitCount3(int x) {
        int count = 0;
        while (x != 0) {
            if (x < 0) {
                count++;
            }
            x = x << 1;
        }
        return count;
    }

    /**
     * 前面的三种解法，运算的次数为二进制数的位数，时间复杂度仍为 O(log2 v) ，然而我们要计算 1 的个数，若让算法的运算次数只与“ 1 ”的个数有关，那复杂度就能进一步降低。
     * 思想： x & (x-1) 可以消去 x 二进制数的最后一位 1
     */
    public int bitCount4(int x) {
        int count = 0;
        while (x != 0)
        {
            x &= x - 1;
            count++;
        }
        return count;
    }

    /**
     * JAVA 的 JDK 库里 Integer 有个 bitCount 方法，其代码是这样实现的
     *
     * 二分法，两两一组相加，之后四个四个一组相加，接着八个八个，最后就得到各位之和了。

     将 0x55555555, 0x33333333, 0x0f0f0f0f 写成二进制数的形式就容易明白了 .
     */
    private int pop(int x)
    {
        /**
         * 第一行是计算每两位中的 1 的个数 , 并且用该对应的两位来存储这个个数 ,
         *如 : 01 10 11 00 -> 01011000 , 即先把前者每两位分段 01 10 11 00 , 分别有 1 1 2 0 个 1, 用两位二进制数表示为 01 01 10 00, 合起来为 01011000.
         *  0x55555555  二进制为1010101010101010101010101010101
         *
         *  如果x为5      即 0101  >>1 变成0010      与0x55555555 取位与后的结果为 0000               0101 - 0000 结果为01 01
         *         6        0110  >>1   0011                                     0001               0110 - 0001 结果为01 01
         *         7        0111  >>1   0011                                     0001               0111 - 0001 结果为01 10
         *         8        1000 >>1    0100                                    0100                1000 - 0100 结果为01 00
         *
         */
        x = x - ((x >> 1) & 0x55555555);
        /**
         * 第二行是计算每四位中的 1 的个数 , 并且用该对应的四位来存储这个个数 .
         如 : 01101100 经过第一行计算后得 01011000 , 然后把 01011000 每四位分段成 0101 1000 ,
                    段内移位相加 : 前段 01+01 =10 ,后段 10+00=10, 分别用四位二进制数表示为 0010 0010, 合起来为 00100010 .

            0x33333333 的二进制为 110011001100110011001100110011
         *
         */
        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
        /**
         *  下面的各行以此类推 , 分别计算每 8 位 ,16 位 ,32 位中的 1 的个数 .
         */
        x = (x + (x >> 4)) & 0x0F0F0F0F;//0x0F0F0F0F    1111000011110000111100001111

        x = x + (x >> 8);

        x = x + (x >> 16);

        return x & 0x0000003F;// 0x0000003F        111111

    }

    /**
     * HAKMEM 算法
     *
     * 首先是将二进制各位三个一组，求出每组中 1 的个数，然后相邻两组归并，得到六个一组的 1 的个数，最后很巧妙的用除 63 取余得到了结果。

         因为 2^6 = 64 ，也就是说  x_0 + x_1 * 64 + x_2 * 64 * 64 = x_0 + x_1 + x_2 (mod 63) ，这里的等号表示同余
     */
    private int pop2(int x) {

        int n;

        n = (x >> 1) & 033333333333;//110011001100110011001100110011001100110011

        x = x - n;

        n = (n >> 1) & 033333333333;

        x = x - n;

        x = (x + (x >> 3)) & 030707070707;//110000011100000111000001110000011100000111

        x = x%63;

        return x;

    }

    public static void main(String[] args) {
        BinaryOperateTest operateTest = new BinaryOperateTest();
        System.out.println(operateTest.pop2(5));
        System.out.println(operateTest.pop(5));
    }


}